""

import numpy as np
import itertools
from functools import reduce
import operator
import time


# def three_tangle(psi):
#     """
#     Coffman-Kundu-Wootters three-tangle for a length-8 complex vector.
#     """
#     idx = lambda a,b,c: (a<<2) + (b<<1) + c
#     a = psi
#     a000, a001, a010, a011 = a[idx(0,0,0)], a[idx(0,0,1)], a[idx(0,1,0)], a[idx(0,1,1)]
#     a100, a101, a110, a111 = a[idx(1,0,0)], a[idx(1,0,1)], a[idx(1,1,0)], a[idx(1,1,1)]

#     d1 = (a000**2 * a111**2 + a001**2 * a110**2 +
#           a010**2 * a101**2 + a100**2 * a011**2)
#     d2 = (a000*a111*(a011*a100 + a101*a010 + a110*a001) +
#           a011*a100*a101*a010 + a011*a100*a110*a001 +
#           a101*a010*a110*a001)
#     d3 = a000*a110*a101*a011 + a111*a001*a010*a100

#     return 4*abs(d1 - 2*d2 + 4*d3)


# ----------- basic 1-qubit gates -----------
I = np.eye(2, dtype=complex)
X = np.array([[0,1],[1,0]],                   complex)
Y = np.array([[0,-1j],[1j,0]],                complex)
Z = np.array([[1,0],[0,-1]],                  complex)
H = np.array([[1,1],[1,-1]],                  complex) / np.sqrt(2)

pauli_1q = {
    'I': np.eye(2, dtype=complex),
    'X': np.array([[0,1],[1,0]], complex),
    'Y': np.array([[0,-1j],[1j,0]], complex),
    'Z': np.array([[1,0],[0,-1]], complex),
}

def paulis_n(n):
    """Return list of all 4^n tensor-products of I,X,Y,Z on n qubits."""
    labels = list(pauli_1q.keys())
    for prod in itertools.product(labels, repeat=n):
        # build the Kron product for this string of labels
        U = pauli_1q[prod[0]]
        for L in prod[1:]:
            U = np.kron(U, pauli_1q[L])
        yield U

# â”€â”€â”€ 2) Test for â€œis a Pauli up to global phaseâ€ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def is_pauli(U: np.ndarray, tol: float = 1e-8) -> bool:
    """
    True iff U â‰ˆ e^{iÏ•}Â·P for some P in the n-qubit Pauli group.
    """
    # find any nonzero entry of U to read off a candidate phase
    for P in paulis_n(U.shape[0].bit_length()-1):
        # pick one nonzero entry of P
        idx = np.flatnonzero(np.abs(P) > tol)
        if idx.size == 0:
            continue
        i = idx[0]
        phase = U.flat[i] / P.flat[i]
        if np.allclose(U, phase * P, atol=tol):
            return True
    return False

# â”€â”€â”€ 3) Level-2 (Clifford) test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def level2_via_M(M: np.ndarray) -> bool:
    """
    M âˆˆ ð’žâ‚‚ iff  âˆ€ P âˆˆ Pauliâ‚™:  M P Mâ€  â‰ˆ Pauli.
    """
    for P in paulis_n(M.shape[0].bit_length()-1):
        if not is_pauli(M @ P @ M.conj().T):
            return False
    return True

# â”€â”€â”€ 4) General level-k test â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def level_via_M(M: np.ndarray, k: int) -> bool:
    """
    Test whether M âˆˆ ð’ž_k on n qubits, by recursion:
      â€¢ ð’žâ‚ = Pauli group (we never call level_via_M(M,1))
      â€¢ ð’žâ‚‚: conjugates Paulis into Paulis (level2_via_M)
      â€¢ ð’ž_k: for all P âˆˆ Pauli, M P Mâ€  âˆˆ ð’ž_{k-1}.
    """
    if k == 2:
        return level2_via_M(M)

    # for k>2, require that for every Pauli P, the â€œconjugatedâ€ M P Mâ€ 
    # lies one level down in the hierarchy:
    for P in paulis_n(M.shape[0].bit_length()-1):
        MPM = M @ P @ M.conj().T
        if not level_via_M(MPM, k-1):
            return False
    return True

# two-qubit CNOT (control=MSBâ†’target=LSB)
CNOT = np.array([
    [1,0,0,0],
    [0,0,0,1],
    [0,0,1,0],
    [0,1,0,0],
], complex)

def kron_n(ops):
    """n-fold Kronecker: reduce(np.kron, ops, 1Ã—1 identity)."""
    return reduce(np.kron, ops, np.array([1], complex))


# ----------- Gottesman â€œp-acidâ€ weighted-degree -----------
def v2(a: int) -> int:
    """2-adic valuation of a>0."""
    return (a & -a).bit_length() - 1

def weighted_degree(coeffs, m, weights):
    """
    For each nonzero c_i in coeffs, weight w_i,
      compute (m - v2(c_i) - 1) + w_i,
    and return the max.
    """
    levels = [
        (m - v2(c) - 1) + w
        for c, w in zip(coeffs, weights)
        if c != 0
    ]
    return max(levels) if levels else 0


# ----------- build the n-qubit â€œtetrahedralâ€ group G_tet -----------
def make_G_tet(n):
    """
    Abelian group generated by {Z_i Z_{i+1} for i=0..n-2} âˆª {X^âŠ—n}.
    Returns list of 2^n unitaries.
    """
    # generators
    gens = []
    for i in range(n-1):
        ops = [I]*n
        ops[i]   = Z
        ops[i+1] = Z
        gens.append(kron_n(ops))
    gens.append(kron_n([X]*n))

    # now build every product
    G = []
    for bits in itertools.product([0,1], repeat=n):
        g = np.eye(2**n, dtype=complex)
        for bit, Gen in zip(bits, gens):
            if bit:
                g = Gen @ g
        G.append(g)
    return G


# ----------- single-qubit Bloch & autocorr -----------
def bloch(v, sys, n):
    """âŸ¨XâŸ©,âŸ¨YâŸ©,âŸ¨ZâŸ© on qubit `sys` of an n-qubit state `v`."""
    out = []
    for P in (X, Y, Z):
        ops = [I]*n
        ops[sys] = P
        O = kron_n(ops)
        out.append(np.vdot(v, O @ v).real)
    return np.array(out)

def autocorr(vecs):
    prods = [u.dot(w) for u in vecs for w in vecs]
    return tuple(sorted(np.round(prods,6)))


def find_all_isotropic_polynomials(n, k,mset=None, min_mag=0.1):
    """
    Enumerate *all* level-k phase-polynomials on n qubits whose
    fiducial has truly isotropic nonzero Bloch magnitudes.
    """

   # 1) list all monomials of degree â‰¥2
    subsets = [
        tuple(sorted(comb))
        for r in range(2, n+1)
        for comb in itertools.combinations(range(n), r)
    ]
    weights = [len(s) for s in subsets]

    # 2) prebuild the CNOT-chain and H on last qubit
    net_H    = kron_n([I]*(n-1) + [H])
    CNOTs    = [kron_n([I]*i + [CNOT] + [I]*(n-i-2)) for i in range(n-1)]
    net_CNOT = reduce(operator.matmul, CNOTs, np.eye(2**n, dtype=complex))
    plus     = np.ones(2**n, complex) * 2**(-n/2)
    G_tet    = make_G_tet(n)

    start    = time.time()
    found    = []

    # loop over precisions m = 1â€¦k
    if mset is None:
        mset = range(1, k+1)
    for m in mset:
    
        mod   = 2**m
        denom = mod


        for coeffs in itertools.product(range(mod), repeat=len(subsets)): ###change back to RANGE mod!!!
            if weighted_degree(coeffs, m, weights) != k:
                continue
            # build f(z)
            def f(z):
                return sum(c for c, sub in zip(coeffs, subsets)
                              if c and all(z[i] for i in sub)) % mod

            # build Df
            phases = [np.exp(2j*np.pi * f(z)/denom)
                      for z in itertools.product([0,1], repeat=n)]
            Df = np.diag(phases)

            # fiducial + basis
            psi       = net_CNOT @ net_H @ Df @ plus
            #basis     = [g @ psi for g in G_tet]
            bloch_vecs = [bloch(psi, q, n) for q in range(n)]

            # compute magnitudes
            abs_comps = [np.abs(v) for v in bloch_vecs]
            comps = [v for v in bloch_vecs]
            mags      = [np.linalg.norm(v) for v in bloch_vecs]

            # check component-isotropy & threshold
            if not all(np.allclose(c, c[0], atol=1e-6) and c[0]>min_mag
                       for c in abs_comps):
                continue
            # check qubit-isotropy
            if not all(abs(m - mags[0])<1e-6 for m in mags):
                continue

            # format polynomial
            terms = []
            for c, sub in zip(coeffs, subsets):
                if c == 0:
                    continue
                var = "*".join(f"z{i+1}" for i in sub)
                terms.append(f"{c}*{var}")
            poly_str = " + ".join(terms) if terms else "0"

            # report
            elapsed = time.time() - start
            print(f"\nðŸŽ‰ Found isotropic at n={n}, level k={k}, precision m={m}")
            print("  phase polynomial:")  
            print(f"    f(z) = {poly_str}   (mod {mod})\n")
            print("  Bloch vectors of |ÏˆâŸ© on each qubit:")
            print("Fiducial is:\n", np.round(psi, 4))
            # print("The fiducial state has tree-tangle:", three_tangle(psi)) #optinionally print 3-tangle
            #print("M =\n", np.round(np.column_stack([g @ psi for g in G_tet]), 6))

            for qi, v in enumerate(bloch_vecs):
                mag = np.linalg.norm(v)
                print(f"    qubit {qi+1}:  âŸ¨X,Y,ZâŸ© = {np.round(v,6)},   |v| = {mag:.6f}")
            print(f"\n  elapsed time: {elapsed:.1f}s")

            found.append((psi, m, coeffs, poly_str))

    if not found:
        print(f"\nNo isotropic solutions for n={n}, k={k}.")
    else:
        print(f"\nTotal isotropic solutions found: {len(found)}")
    return found

def search_isotropic(n, k, min_mag=0.1):
    """
    Search for *any* phaseâ€polynomial on n qubits in C_k whose fiducial
    has all local Blochâ€magnitudes equal and > min_mag.  
    Prints and returns (m, coeffs, subsets) on first success.
    """
    # 1) list all nonempty monomials (as tuples of indices) and their weights
    subsets = [
        tuple(comb)
        for r in range(1, n+1)
        for comb in itertools.combinations(range(n), r)
    ]
    weights = [len(s) for s in subsets]

    # 2) prebuild net_H = IâŠ—â€¦âŠ—IâŠ—H, and the CNOTâ€chain
    net_H    = kron_n([I]*(n-1) + [H])
    CNOTs    = [kron_n([I]*i + [CNOT] + [I]*(n-i-2)) for i in range(n-1)]
    net_CNOT = reduce(operator.matmul, CNOTs, np.eye(2**n, dtype=complex))
    plus     = np.ones(2**n, dtype=complex)/np.sqrt(2**n)
    G_tet    = make_G_tet(n)

    start = time.time()
    # 3) scan precisions m=1â€¦k
    for m in range(1, k+1):
        mod   = 2**m
        denom = mod
        # 4) enumerate all coefficientâ€tuples on those subsets
        for coeffs in itertools.product(range(mod), repeat=len(subsets)):
            # quick Gottesman levelâ€check
            if weighted_degree(coeffs, m, weights) != k:
                continue

            # 5) build f(z) from these coeffs
            def f(z, c=coeffs):
                s = 0
                for ci, sub in zip(c, subsets):
                    if ci and all(z[i] for i in sub):
                        s += ci
                return s % mod

            # 6) build Df, fiducial psi, and the tetrahedral basis
            phases = [
                np.exp(2j * np.pi * f(z)/denom)
                for z in itertools.product([0,1], repeat=n)
            ]
            Df    = np.diag(phases)
            psi   = net_CNOT @ net_H @ Df @ plus

            # 7) check first basisâ€vectorâ€™s local Bloch vectors for true isotropy
            bloch_vecs = [bloch(psi, q, n) for q in range(n)]
            abs_comps  = [np.abs(v) for v in bloch_vecs]
            mags       = [np.linalg.norm(v) for v in bloch_vecs]

            # Option to check for all values equal (not just same abs values)
            # Set this flag to True to require all Bloch vector components to be equal (not just same magnitude)
            require_all_equal = True  # Set to True for strict equality

            ok = True
            if require_all_equal:
                # All Bloch vector components must be (approximately) equal across all qubits
                ref = bloch_vecs[0]
                for v in bloch_vecs:
                    if not np.allclose(v, ref, atol=1e-6):
                        ok = False
                        break
                # Also check that each component is above min_mag in magnitude
                if ok and not all(np.all(np.abs(v) > min_mag) for v in bloch_vecs):
                    ok = False
            else:
                # Original: all components of each Bloch vector have same abs value, and all qubits have same norm
                for comp in abs_comps:
                    if not (np.allclose(comp, comp[0], atol=1e-6) and comp[0] > min_mag):
                        ok = False
                        break
                if ok:
                    if not all(np.allclose(np.abs(comp), np.abs(abs_comps[0]), atol=1e-6) for comp in abs_comps):
                        ok = False
                    if not all(abs(m - mags[0]) < 1e-6 for m in mags):
                        ok = False


            if ok:
                elapsed = time.time() - start

                # Build a humanâ€readable polynomial string
                terms = []
                for c, sub in zip(coeffs, subsets):
                    if c == 0:
                        continue
                    # variable names z1, z2, â€¦ 
                    var = "*".join(f"z{i+1}" for i in sub)
                    terms.append(f"{c}*{var}")
                poly_str = " + ".join(terms) if terms else "0"

                print(f"\nðŸŽ‰ Found isotropic at n={n}, level k={k}, precision m={m}")
                print("  phase polynomial:")
                print(f"    f(z) = {poly_str}   (mod {mod})\n")
                print("  Bloch vectors of |ÏˆâŸ© on each qubit:")
                for qi, v in enumerate(bloch_vecs):
                    mag = np.linalg.norm(v)
                    print(f"    qubit {qi+1}:  âŸ¨X,Y,ZâŸ© = {np.round(v,6)},   |v| = {mag:.6f}")
                print(f"\n  elapsed time: {elapsed:.1f}s")
                basis = [g @ psi for g in G_tet]
                print('The fiducial is:\n', np.round(psi, 4))
                M   = np.column_stack(basis)
                print("M =\n", np.round(M, 6))
            
               # print("Is M a level-k gate?", level_via_M(M, k))
                return (m, coeffs, subsets)

    print(f"No isotropic polynomial found for n={n}, k={k} (scanned mâ‰¤{k}).")
    return None

# Example usage:
if __name__ == "__main__":
    # Example: Find all isotropic polynomials for n=3, k=4
    find_all_isotropic_polynomials(n=2, k=3, mset ={2,3,4})
    #np.save('fiducials_120.npy', np.array(found, dtype=object), allow_pickle=True) # save as npy array for later analysis
    # Example: Search for any isotropic polynomial for n=3, k=4
    #search_isotropic(n=3 k=5)
